free c:channel.
free s:bitstring [private].

type skey.
type pkey.
type sskey.
type spkey.
type key.

fun pk(skey): pkey.
fun aenc(bitstring, pkey): bitstring.
reduc forall m: bitstring, k: skey; adec(aenc(m, pk(k)),k)=m.

fun spk(sskey): spkey.
fun sign(bitstring, sskey): bitstring.
reduc forall m: bitstring, k: sskey; getmess(sign(m,k))=m.
reduc forall m: bitstring, k: sskey; checksign(sign(m,k),spk(k))=m.

fun senc(bitstring, key): bitstring.
reduc forall m:bitstring, k:key; sdec(senc(m,k),k)=m.

query attacker(s).

let clientA(pkA:pkey,skA:skey,pkB:spkey) =
	out(c,pkA);
	in(c,x:bitstring);
	let y = adec(x,skA) in (*y = sign((pkB,k),skB)*)
	let (=pkB,k:key) = checksign(y,pkB) in (*checksign(sign(m,k),spk(k))=m.*)
	out(c,senc(s,k)).

let serverB(pkB:spkey,skB:sskey) =
	in(c,pkX:pkey);
	new k:key;
	out(c,aenc(sign((pkB,k),skB),pkX));
	in(c,x:bitstring);
	let z = sdec(x,k) in
	0.

process
	new skA:skey;
	new skB:sskey;
	let pkA = pk(skA) in out(c,pkA);
	let pkB = spk(skB) in out(c,pkB);
	( (!clientA(pkA,skA,pkB)) | (!serverB(pkB,skB)) )