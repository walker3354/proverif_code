free ch1: channel.
free ch2: channel.

(*secret key*)
free p_t: bitstring[private].
free p_v: bitstring[private].
free p_u: bitstring[private].

(*secret*)
free s_message:bitstring[private].

(*session key*)
free Sk_vu: bitstring[private].
free Sk_uv: bitstring[private].


const IDV: bitstring.
const IDU: bitstring.

(* ECC operation *)
const P: bitstring.
const d: bitstring [private]. (*完全沒用*)
fun mult(bitstring, bitstring): bitstring.
fun addt(bitstring, bitstring): bitstring.

(* Number operation *)
fun mod(bitstring, bitstring): bitstring.
fun inv(bitstring): bitstring.(*reciprocal*)
fun mul(bitstring, bitstring): bitstring.(*幕次*)
fun add(bitstring, bitstring): bitstring.
fun div(bitstring, bitstring): bitstring.
fun minus(bitstring): bitstring.

(*hash*)
fun hash1(bitstring): bitstring.

(* symmetric key encryption *)
type key.
fun s_mul(bitstring,bitstring):key.
fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.

(*event*)
event initial_process_v(bitstring).
event initial_process_u(bitstring).
event term_process_v(bitstring).
event term_process_u(bitstring).

(*attacker*)
query attacker(p_t).
query attacker(p_v).
query attacker(p_u).
query attacker(Sk_uv).
query attacker(Sk_vu).
query attacker(s_message).
query x: bitstring; inj-event(term_process_v(x)) ==> inj-event(initial_process_v(x)).
query x: bitstring; inj-event(term_process_u(x)) ==> inj-event(initial_process_u(x)).


(*t*)
let process_t = 
    new pf: bitstring;
    new pc: bitstring;
    let p_t = mul(pf, P) in
    let Q_t = mul(p_t, P) in

    (*v registe*)
    in(ch1, IDV: bitstring);
    new rtv: bitstring;
    let Ai_v = add(p_t, mult(IDV, rtv)) in
    let Ar_v = rtv in
    out(ch1, (Ai_v, Ar_v,Q_t)).

(*v*)
let process_v(kc:key) =
    (*regsite phase*)
    event initial_process_v(IDV);
    out(ch1, IDV);
    new rv: bitstring;
    in(ch1, (Ai_v: bitstring, Ar_v: bitstring, Q_t:bitstring));
    let p_v = mul(Ai_v, rv) in
    let Q_v = mul(p_v, P) in

    (*broadcast*)
    let E_Q_v = senc(Q_v, kc) in
    out(ch2,(Ai_v, Ar_v, E_Q_v, Q_t));

    (*receive u public key*)
    in(ch2, E_Q_u: bitstring);
    let Q_u = sdec(E_Q_u, kc) in
    let Sk_vu = s_mul(p_v, Q_u) in

    (*test session key*)
    in(ch2, es_message: bitstring);
    let temp_message = sdec(es_message, Sk_vu) in
    if temp_message = s_message then
        event term_process_v(IDV).

(*u*)
let process_u (kc:key)= 
    (*regsite phase*)
    event initial_process_u(IDU);
    let Q_u = mul(p_u, P) in

    (*receive v  broadcast*)
    in(ch2, (Ai_v: bitstring, Ar_v: bitstring, E_Q_v: bitstring, Q_t: bitstring));
    let Q_v = sdec(E_Q_v, kc) in

    (*verify V passed registe*)
    if Ai_v = add(Q_t,mul(IDV,Ar_v)) then
        let E_Q_u = senc(Q_u, kc) in
        let Sk_uv = s_mul(p_u,Q_v) in 
        out(ch2, E_Q_u);

        (*test session key*)
        let es_message = senc(s_message, Sk_uv) in
        out(ch2, es_message);
        event term_process_u(IDU).

(*main process*)
process
    new kc: key;
    ((!process_t)|(process_v(kc))|(process_u(kc)))